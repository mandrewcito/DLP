% Usar el tipo de documento: Artículo científico.
\documentclass[12pt,a4paper]{article}

% Cargar mensajes en español.
\usepackage[spanish]{babel}

% Usar codificación utf-8 para acentos y otros.
\usepackage[utf8]{inputenc}

% Aprovechar más los márgenes de la página
\usepackage{fullpage}
% Insertar porcifullpageones de código
\usepackage{listings}

% Configuración para porciones de código
\lstset{
%	language=bash,
	basicstyle=\ttfamily\small,
%	numberstyle=\footnotesize,
%	numbers=left,
%	backgroundcolor=\color{gray!10},
%	frame=single,
	tabsize=4,
%	rulecolor=\color{black!30},
%	title=\lstname,
%	escapeinside={\%*}{*)},
	breaklines=true,
	breakatwhitespace=true,
%	framextopmargin=2pt,
%	framexbottommargin=2pt,
	extendedchars=false,
	inputencoding=utf8
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Propiedades
\title{Análisis de las caraterísticas de un conjunto de lenguajes de
programación a partir de un caso práctico}

\author{Andrés Baamonde Lozano (andres.baamonde@udc.es)\\
	Rodrigo Arias Mallo (rodrigo.arias@udc.es)}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Descripción}

En el presente documento se describen varias soluciones a un mismo problema,
realizadas en diferentes lenguajes de programación. El problema consiste en
eliminar los estados finales de un autómata. El autómata debe ser finito y
determinista, abreviado AFD. Tras este proceso, se obtendrá una nueva versión
del autómata inicial, el autómata conexo equivalente.  

\subsection{Estructura}

Para representar un AFD $M = \{ Q, \Sigma, s, F, \Delta \} $, se ha empleado una 
lista para cada uno de sus componentes, exceptuando al estado inicial $s$, que 
consta de un sólo elemento.

Tanto un estado como un símbolo, están contituídos por una cadena de caracteres.  
Una transición contiene dos estados, inicial y final, y un símbolo.

\begin{lstlisting}

Objeto Automata:
	estados:Lista<String>
	alfabeto:Lista<String>
	estadosFinales:Lista<String>
	estadoInicial:String
	transiciones:Lista<Transicion>

Objeto Transicion:
	estadoInicial:String
	estadoFinal:String
	simbolo:String

\end{lstlisting}
\subsection{Parsing fichero}
Esta función correspondería con el init del objeto en Python.
\begin{lstlisting}

funcion inicializarAutomata(fichero configuracion):
	String linea = Primera linea (fichero configuracion)
	String lineas[] = Dividir linea por ";"
	estados=lineas[1]; alfabeto = lineas[2];
	estadosFinales=Lineas[3];estadoInicial=Linea[4];
	Desde i=5 hasta tamaño(linea) hacer :
	  Añadir a Transiciones(nueva transicion linea[i]);
	  
\end{lstlisting}

\subsection{Algoritmo}
El algoritmo que calcula el autómata conexo equivalente, se muestra a 
continuación en pseudocódigo.
\begin{lstlisting}

funcion conexo(afd:Automata):
	listaEstados = Lista vacia
	listaEstados.add(afd.estadoInicial)
	nuevasTransiciones = Lista vacia
	visitados = Lista vacia
	while listaEstados != vacia:
		elem = listaEstados[0]
		visitados.add(elem)
		para trans en afd.transiciones:
			si (trans.ini == elem):
				nuevasTransiciones.add(trans)
				si ((trans.fin no esta en visitados) y
				(trans.fin no esta en listaEstados):
					listaEstados.add(trans.fin)					
	afd.transiciones=nuevasTransiciones

\end{lstlisting}

\section{Python (Lenguaje original)}

Como lenguaje original hemos elegido Python, por su sencillez ya que es
prácticamente pseudocódigo, hemos creado un objeto autómata. para guardar el
autómata y sus transiciones, que también les hemos creado un objeto para ellas.

\subsection{Compilador versión y el sistema operativo empleado}
Python 2.7.6, Ubuntu 64b 14.04


\subsection{Características generales del lenguaje}
  Lenguaje de programación multiparadigma
  Soporta orientación a objetos 
  Programación imperativa 
  Programación funcional(en menor medida) 
  Lenguaje interpretado
  Tipado dinámico
  Multiplataforma
  Conteo de referencias(para eliminar bloques no usados)
  Resolución dinámica de nombres
  Las variables se definen de forma dinámica
  Listas mutables(se puede cambiar su contenido en tiempo de ejecución)
  Tuplas inmutables
  Listas y tuplas pueden contener elementos de diferentes tipos
  
  \subsection{Análisis detallado}
  Fácil lecutra (casi pseudocodigo), todas las listas son iterables no necesitas crear un iterador, ventaja de debug en consola de modo interactivo
  las listas ademas pueden contener varios tipos de datos no como en java, hasta pueden contener tuplas. como lenguaje original es una buena eleccion ya
   que es de muy alto nivel, la entrada salida es sencilla. tiene la desventaja de que no podemos gestionar la memoria en ningun momento .
    
  \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
  Diseñaremos el autómata con dos objetos, el resto de lenguaje serán de más bajo nivel que Python, tendremos que utilizar más recursos.
  \subsection{Características que no se pudieron aprovechar del lenguaje}
  No se ha usado la programación funcional, ni la list comprehesion, no utilizamos recursión en el algoritmo pero se podría,eso si, modificando el algoritmo. También se podría utilizado conjuntos pero el resto de lenguajes que usamos carecen de ellos por lo que se optó una implmentación con listas.
  \section{Java}
   \subsection{Compilador versión y el sistema operativo empleado}
   JAVA 8, Ubuntu 64b 14.04
    \subsection{Características generales del lenguaje}
    Lenguaje de programación de propósito general
    Concurrente
    Orientado a objetos 
    Recolector de basura (para evitar fugas de memoria)
    Variables: no se definen de forma dinámica ( se especifica el tipo antes de usarla)
    Diseñado para ofrecer seguridad y portabilidad, y no ofrece acceso directo al hardware de la arquitectura ni al espacio de direcciones.
    Recolector de basura puede suponer una carga para el sistema(sistemas en tiempo real)
	No dispone de operadores de sobrecarga definidos por el usuario
	No es un lenguaje absolutamente orientado a objetos, no todos los valores son objetos.
	
    \subsection{Análisis detallado}
    
    muy parecido al lenguaje original, con la diferencia de las listas, que necesitan un iterador para recorrerlas y no se pueden iterar
    directamente como en python, además la entrada salida se tiene que manejar a mayores con excepciones y en general es un poco mas laborioso que
    en python, en cuanto a la orientacion a objetos es igual. solo se han cambiado las listas de python por los arrayList de java
    \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
    Diseñaremos el automata con dos objetos, con la modificacion de las listas que ahora son array list.Con la salvedad de que el código Java puede ser a veces redundante en comparación con otros lenguajes
    \subsection{Características que no se pudieron aprovechar del lenguaje}
    Casi ninguna de las multiples librerías ya que no eran necesarias
     \section{Haskell}
       \subsection{Compilador versión y el sistema operativo empleado}
       The Glorious Glasgow Haskell Compilation System, version 7.6.3
       Ubuntu 14 64b
       \subsection{Características generales del lenguaje}
       	No ejecuta funciones ni realiza cálculos hasta que se ve forzado a hacerlo
        Tipado estático(captura más errores antes de la ejecución)
        Sistema de tipos con inferencia de tipos(permite código más general).
        Paragidma funcional
        Modo interactivo (práctico para debug)
        Módulos:colección de funciones, tipos y clases de tipos relacionadas entre sí.
        Haskell no proporciona el estilo de sobrecarga.
       \subsection{Análisis detallado}
        Como en haskell no tenemos objetos, se han creado tipos data(uno para las transiciones y otro para el autómata), también tendremos metodos asociados a eses tipos pero en haskell se separa la definición de los métodos del tipo.
        
       \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
       Lo más intuitivo para substituir los objetos eran los tipos data, en el caso del algoritmo se ha cambiado un poco más el funcionamiento para poder ajustarlo a la programación funcional y evitar utilizar haskell como un lenguaje de programación imperativa normal
       \subsection{Características que no se pudieron aprovechar del lenguaje}
       Una de las "mejores del lenguaje" los texas rangos(por la naturaleza del problema no eran de utilidad) : ['a'..'z'], cycle,repeat (...) Listas intensionales [x*2 | x <- [1..10]], zip de las listas,“pattern matching” de las funciones antes de implementarlas
      \section{C}
       \subsection{Compilador versión y el sistema operativo empleado}
        \subsection{Características generales del lenguaje}
        \subsection{Análisis detallado}
        \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
        \subsection{Características que no se pudieron aprovechar del lenguaje}
          \section{Ensamblador}
           \subsection{Compilador versión y el sistema operativo empleado}04
            \subsection{Características generales del lenguaje}
            \subsection{Análisis detallado}
            \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
            \subsection{Características que no se pudieron aprovechar del lenguaje}
\end{document}
