% Usar el tipo de documento: Artículo científico.
\documentclass[12pt,a4paper]{article}

% Cargar mensajes en español.
\usepackage[spanish]{babel}

% Usar codificación utf-8 para acentos y otros.
\usepackage[utf8]{inputenc}

% Aprovechar más los márgenes de la página
\usepackage{fullpage}

% Insertar porciones de código
\usepackage{listings}

% Configuración para porciones de código
\lstset{
%	language=bash,
	basicstyle=\ttfamily\small,
%	numberstyle=\footnotesize,
%	numbers=left,
%	backgroundcolor=\color{gray!10},
%	frame=single,
	tabsize=4,
%	rulecolor=\color{black!30},
%	title=\lstname,
%	escapeinside={\%*}{*)},
	breaklines=true,
	breakatwhitespace=true,
%	framextopmargin=2pt,
%	framexbottommargin=2pt,
	extendedchars=false,
	inputencoding=utf8
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Propiedades
\title{Análisis de las caraterísticas de un conjunto de lenguajes de
programación a partir de un caso práctico}

\author{Andrés Baamonde Lozano (andres.baamonde@udc.es)\\
	Rodrigo Arias Mallo (rodrigo.arias@udc.es)}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Descripción}

En el presente documento se describen varias soluciones a un mismo problema,
realizadas en diferentes lenguajes de programación. El problema consiste en
eliminar los estados finales de un autómata. El autómata debe ser finito y
determinista, abreviado AFD. Tras este proceso, se obtendrá una nueva versión
del autómata inicial, el autómata conexo equivalente.  

\subsection{Estructura}

Para representar un AFD $M = \{ Q, \Sigma, s, F, \Delta \} $, se ha empleado una 
lista para cada uno de sus componentes, exceptuando al estado inicial $s$, que 
consta de un sólo elemento.

Tanto un estado como un símbolo, están contituídos por una cadena de caracteres.  
Una transición contiene dos estados, inicial y final, y un símbolo.

\begin{lstlisting}

Objeto Automata:
	estados:Lista<String>
	alfabeto:Lista<String>
	estadosFinales:Lista<String>
	estadoInicial:String
	transiciones:Lista<Transicion>

Objeto Transicion:
	estadoInicial:String
	estadoFinal:String
	simbolo:String

\end{lstlisting}

\subsection{Algoritmo}
El algoritmo que calcula el autómata conexo equivalente, se muestra a 
continuación en pseudocódigo.

\begin{lstlisting}
funcion conexo(afd:Automata):
	listaEstados = Lista vacia
	listaEstados.add(afd.estadoInicial)
	nuevasTransiciones = Lista vacia
	visitados = Lista vacia

	while listaEstados != vacia:
		elem = listaEstados[0]
		visitados.add(elem)
		para trans en afd.transiciones:
			si (trans.ini == elem):
				nuevasTransiciones.add(trans)
				si ((trans.fin no esta en visitados) y
				(trans.fin no esta en listaEstados):
					listaEstados.add(trans.fin)
					
	afd.transiciones=nuevasTransiciones

\end{lstlisting}

\section{Lenguaje original (Python)}

Como lenguaje original hemos elegido Python, por su sencillez ya que es
prácticamente pseudocódigo, hemos creado un objeto autómata. para guardar el
autómata y sus transiciones, que también les hemos creado un objeto para ellas.


\subsection{Pseudocódigo estructuras}

\begin{lstlisting}
Objeto Automata:
estados:Lista
	afabeto:Lista
	estadosFinales:Lista
	estadoInicial:String
	Transiciones:Lista<Transiciones>
Objeto Transicion: 
	inicial:String
	final:String
	simbolo:String

funcion inicializarAutomata(fichero configuracion):
	String linea = Primera linea (fichero configuracion)
	String lineas[] = Dividir linea por ";"
	estados=lineas[1]; alfabeto = lineas[2];
	estadosFinales=Lineas[3];estadoInicial=Linea[4];
	Desde i=5 hasta tamaño(linea) hacer :
	Añadir a Transiciones(nueva transicion linea[i]);

funcion conexo():
	colaEstados=Lista vacia
	colaEstados.añadir(estadoInicial)
	nuevasTransiciones=Lista vacia
	visitados=Lista vacia
	mientras (tamaño(colaEstados)!=0):
		elem=colaEstados.pop()
		visitados.añadir(elem)
		para trans in Transiciones:
			si (trans.ini==elem):
				nuevasTransiciones.añadir(trans)
				si(trans.fin no esta en	visitados ni en colaEstados):
					colaEstados.añadir(trans.fin)
	Transiciones=nuevasTransiciones
\end{lstlisting}

\subsection{Compilador versión y el sistema operativo empleado}
Python 2.7.6, Ubuntu 64b 14.04


\subsection{Características generales del lenguaje}
  Se trata de un lenguaje de programación multiparadigma, ya que soporta orientación a objetos, pr																												ogramación imperativa y, en menor medida, programación funcional. Es un lenguaje interpretado, usa tipado dinámico y es multiplataforma.
  \subsection{Análisis detallado}
  Fácil lecutra ( casi pseudocodigo), todas las listas son iterables no necesitas crear un iterador, ventaja de debug en consola de modo interactivo
  las listas ademas pueden contener varios tipos de datos no como en java, hasta pueden contener tuplas. como lenguaje original es una buena eleccion ya
   que es de muy alto nivel, la entrada salida es sencilla. tiene la desventaja de que no podemos gestionar la memoria en ningun momento .
  
  \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
  Diseñaremos el automata con dos objetos, el resto de lenguaje seran de mas bajo nivel que python, tendremos que utilizar mas recursos
  \subsection{Características que no se pudieron aprovechar del lenguaje}
  \section{Java}
   \subsection{Compilador versión y el sistema operativo empleado}
   JAVA 8, Ubuntu 64b 14.04
    \subsection{Características generales del lenguaje}
    Java es un lenguaje de programación de propósito general, concurrente, orientado a objetos y basado en clases que fue diseñado específicamente para tener tan pocas dependencias de implementación como fuera posible.
    En Java el problema fugas de memoria se evita en gran medida gracias a la recolección de basura
    \subsection{Análisis detallado}
    muy parecido al lenguaje original, con la diferencia de las listas, que necesitan un iterador para recorrerlas y no se pueden iterar
    directamente como en python, además la entrada salida se tiene que manejar a mayores con excepciones y en general es un poco mas laborioso que
    en python, en cuanto a la orientacion a objetos es igual. solo se han cambiado las listas de python por los arrayList de java
    \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
    diseñaremos el automata con dos objetos, con la modificacion de las listas que ahora son array list.
    \subsection{Características que no se pudieron aprovechar del lenguaje}
      \section{C}
       \subsection{Compilador versión y el sistema operativo empleado}04
        \subsection{Características generales del lenguaje}
        \subsection{Análisis detallado}
        \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
        \subsection{Características que no se pudieron aprovechar del lenguaje}
          \section{Ensamblador}
           \subsection{Compilador versión y el sistema operativo empleado}04
            \subsection{Características generales del lenguaje}
            \subsection{Análisis detallado}
            \subsection{Justificaciones respecto a las decisiones de diseño e implementación}
            \subsection{Características que no se pudieron aprovechar del lenguaje}
\end{document}
