% Usar el tipo de documento: Artículo científico.
\documentclass[12pt,a4paper]{article}

% Cargar mensajes en español.
\usepackage[spanish]{babel}

% Usar codificación utf-8 para acentos y otros.
\usepackage[utf8]{inputenc}

% Aprovechar más los márgenes de la página
\usepackage{fullpage}

% Insertar porciones de código
\usepackage{listings}

% Configuración para porciones de código
\lstset{
%	language=bash,
	basicstyle=\ttfamily\small,
%	numberstyle=\footnotesize,
%	numbers=left,
%	backgroundcolor=\color{gray!10},
%	frame=single,
	tabsize=4,
%	rulecolor=\color{black!30},
%	title=\lstname,
%	escapeinside={\%*}{*)},
	breaklines=true,
	breakatwhitespace=true,
%	framextopmargin=2pt,
%	framexbottommargin=2pt,
	extendedchars=false,
	inputencoding=utf8
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Propiedades
\title{Análisis de las caraterísticas de un conjunto de lenguajes de
programación a partir de un caso práctico}

\author{Andrés Baamonde Lozano (andres.baamonde@udc.es)\\
	Rodrigo Arias Mallo (rodrigo.arias@udc.es)}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Descripción}

En el presente documento se describen varias soluciones a un mismo problema,
realizadas en diferentes lenguajes de programación. El problema consiste en
eliminar los estados finales de un autómata. El autómata debe ser finito y
determinista, abreviado AFD. Tras este proceso, se obtendrá una nueva versión
del autómata inicial, el autómata conexo equivalente.  

\subsection{Estructura}

Para representar un AFD, $M = \{ Q, \Sigma, s, F, \Delta \} $, se ha empleado una 
lista para cada uno de sus componentes, exceptuando al estado inicial $s$, que 
consta de un sólo elemento.

Tanto un estado como un símbolo, están contituídos por una cadena de caracteres.  
Una transición contiene dos estados, inicial y final, y un símbolo.

\begin{lstlisting}

Objeto Automata:
	estados:Lista<String>
	alfabeto:Lista<String>
	estadosFinales:Lista<String>
	estadoInicial:String
	transiciones:Lista<Transicion>

Objeto Transicion:
	estadoInicial:String
	estadoFinal:String
	simbolo:String

\end{lstlisting}

\subsection{Algoritmo}
El algoritmo que calcula el autómata conexo equivalente, se muestra a 
continuación en pseudocódigo.

\begin{lstlisting}
funcion conexo(afd:Automata):
	listaEstados = Lista vacia
	listaEstados.add(afd.estadoInicial)
	nuevasTransiciones = Lista vacia
	visitados = Lista vacia

	while listaEstados != vacia:
		elem = listaEstados[0]
		visitados.add(elem)
		para trans en afd.transiciones:
			si (trans.ini == elem):
				nuevasTransiciones.add(trans)
				si ((trans.fin no esta en visitados) y
				(trans.fin no esta en listaEstados):
					listaEstados.add(trans.fin)
					
	afd.transiciones=nuevasTransiciones

\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lenguaje original (Python)}
Como lenguaje original se ha elegido Python, por su sencillez ya que es muy
similar al pseudocódigo. El autómata se ha representado como un objeto. De igual 
modo, una transición es también un objeto.

\subsection{Versión y Sistema Operativo}
Python 2.7.6 y Ubuntu 14.04 de 64 bits.

\subsection{Características generales del lenguaje}
Se trata de un lenguaje de programación multiparadigma, ya que soporta 
orientación a objetos, programación imperativa y, en menor medida, programación 
funcional. Es un lenguaje interpretado, usa tipado dinámico y es 
multiplataforma.

\subsection{Análisis detallado}
\subsubsection{Ventajas}
\begin{itemize}
\item Fácil lectura (casi pseudocodigo).
\item Listas iterables sin necesidad de iteradores.
\item Depuración sencilla en consola de modo interactivo.
\item Las listas pueden contener varios tipos de datos, hasta pueden contener 
tuplas.
\item Muy alto nivel.
\item La entrada salida es sencilla.
\end{itemize}
\subsubsection{Desventajas}
\begin{itemize}
\item No permite la gestión manual de la memoria.
\end{itemize}
  
\subsection{Justificaciones respecto a las decisiones de diseño e implementación}
Diseñaremos el automata con dos objetos, el resto de lenguaje seran de mas bajo 
nivel que python, tendremos que utilizar mas recursos

\subsection{Pseudocódigo estructuras}
\begin{lstlisting}
Objeto Automata:
	estados:Lista
	afabeto:Lista
	estadosFinales:Lista
	estadoInicial:String
	Transiciones:Lista<Transiciones>

Objeto Transicion: 
	inicial:String
	final:String
	simbolo:String

funcion inicializarAutomata(fichero configuracion):
	String linea = Primera linea (fichero configuracion)
	String lineas[] = Dividir linea por ";"
	estados=lineas[1]; alfabeto = lineas[2];
	estadosFinales=Lineas[3];estadoInicial=Linea[4];
	Desde i=5 hasta tamaño(linea) hacer :
	Añadir a Transiciones(nueva transicion linea[i]);

funcion conexo():
	colaEstados=Lista vacia
	colaEstados.añadir(estadoInicial)
	nuevasTransiciones=Lista vacia
	visitados=Lista vacia
	mientras (tamaño(colaEstados)!=0):
		elem=colaEstados.pop()
		visitados.añadir(elem)
		para trans in Transiciones:
			si (trans.ini==elem):
				nuevasTransiciones.añadir(trans)
				si(trans.fin no esta en	visitados ni en colaEstados):
					colaEstados.añadir(trans.fin)
	Transiciones=nuevasTransiciones
\end{lstlisting}

\subsection{Características que no se pudieron aprovechar del lenguaje}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Java}
\subsection{Compilador versión y el sistema operativo empleado}
   JAVA 8, Ubuntu 64b 14.04

\subsection{Características generales del lenguaje}
    Java es un lenguaje de programación de propósito general, concurrente, orientado a objetos y basado en clases que fue diseñado específicamente para tener tan pocas dependencias de implementación como fuera posible.
    En Java el problema fugas de memoria se evita en gran medida gracias a la recolección de basura

\subsection{Análisis detallado}
    muy parecido al lenguaje original, con la diferencia de las listas, que necesitan un iterador para recorrerlas y no se pueden iterar
    directamente como en python, además la entrada salida se tiene que manejar a mayores con excepciones y en general es un poco mas laborioso que
    en python, en cuanto a la orientacion a objetos es igual. solo se han cambiado las listas de python por los arrayList de java
\subsection{Justificaciones respecto a las decisiones de diseño e implementación}
    diseñaremos el automata con dos objetos, con la modificacion de las listas que ahora son array list.
\subsection{Características que no se pudieron aprovechar del lenguaje}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lenguaje C}
\subsection{Compilador versión y el sistema operativo empleado}
Compilador:
\begin{lstlisting}
gcc (GCC) 4.9.1 20140903 (prerelease)
\end{lstlisting}
Sistema operativo:
\begin{lstlisting}
Linux 3.16.4-1 x86_64 GNU/Linux
\end{lstlisting}

\subsection{Características generales del lenguaje}
Es un lenguaje imperativo procedural y funcional. Se considera de medio nivel,
aunque incluye operaciones de bajo nivel, directamente escritas en ensamblador.

Emplea un tipado fuertemente estático que impide realizar operaciones sin
sentido. Sin embargo no tiene programación orientada a objetos, ni recolección
de basura.
\subsection{Análisis detallado}
\subsubsection{Ventajas}
\begin{itemize}
\item Incluye un preprocesador muy útil para crear macros.
\item Emplea punteros para la gestión de la memoria.
\item Contiene estructuras.
\item Permite la recursión.
\item Pocas palabras clave
\end{itemize}

\subsubsection{Desventajas}
\begin{itemize}
\item No tiene recolector de basura.
\item No implementa programación orientada a objetos.
\item No dipone de programación multihilo de forma nativa.
\item No tiene protección de memoria para accesos inválidos.
\end{itemize}

\subsection{Justificaciones respecto a las decisiones de diseño e implementación}
Para la implementación en C, se ha seguido la aproximación inicial, empleando
listas doblemente enlazadas. El autómata es una estructura, que contiene las
listas.

La implementación de las listas se ha logrado empleando punteros, y funciones
que ofrecen una interfaz para el acceso a los elementos.

Esta elección mantiene una gran similaritud con la primera aproximación.
Almacenar el autómata en forma de estructura, mantiene los elementos ordenados y
clasificados, facilitando su uso y comprensión.

La entrada y salida de la configuración del autómata se ha realizado usando la
entrada y salida estándar. Para ello se usan funciones como fgets y printf.

\subsection{Características que no se pudieron aprovechar del lenguaje}
La recursión, ya que la implementación original no la requería. Se podría haber
empleado, modificando el algoritmo, para incluirla, pero requeriría mantener una
lista de elementos ya visitados, para evitar lazos. Por lo demás el algoritmo
sería muy similar.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lenguaje ensamblador (NASM)}
\subsection{Compilador versión y el sistema operativo empleado}
Compilador:
\begin{lstlisting}
NASM version 2.11.05 compiled on May 31 2014
gcc (GCC) 4.9.1 20140903 (prerelease)
\end{lstlisting}
Sistema operativo:
\begin{lstlisting}
Linux 3.16.4-1 x86_64 GNU/Linux
\end{lstlisting}

\subsection{Características generales del lenguaje}
Ensamblador en una abstracción de las instrucciones de procesador, para que
resulten más memorizables. Además el compilador elegido, NASM, contiene
etiquetas, que evitan manejar directamente las posiciones de memoria.

\subsection{Análisis detallado}
\subsubsection{Ventajas}
\begin{itemize}
\item Permite construir código optimizado para una máquina específica.
\item Aprendizaje de la estructura interna del procesador.
\item Aprovechar la memoria caché y los registros.
\end{itemize}

\subsubsection{Desventajas}
\begin{itemize}
\item No tiene estructuras de control, sólo saltos.
\item Gestión de la memoria y pila de forma manual.
\item No implementa programación orientada a objetos.
\item No dipone de programación multihilo de forma nativa.
\item No tiene protección de memoria para accesos inválidos.
\item Transformar un problema de alto nivel a bajo nivel es muy complejo.
\item Programación muy lenta.
\item La depuración es un proceso costoso, y también muy lento.
\item Depende de la arquitectura de la máquina.
\end{itemize}


\subsection{Justificaciones respecto a las decisiones de diseño e 
implementación}
Es muy diferente al lenguaje inicial. Para su implementación de ha elegido sólo 
la parte del algoritmo que genera el autómata mínimo conexo. Las funciones de 
entrada de la configuración, así como las estructuras de datos, y listas, se han 
empleado del lenguaje C. Esta elección, es debida a la enorme complejidad en la 
que resultaría, realizar todo el programa en ensamblador.

El algoritmo es una traducción del programa en C a ensamblador. Cada línea es 
codificada con algunas instrucciones. Los bucles se forman con saltos y 
etiquetas.

\end{document}
