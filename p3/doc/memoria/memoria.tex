% Usar el tipo de documento: Artículo científico.
\documentclass[12pt,a4paper]{article}

% Cargar mensajes en español.
\usepackage[spanish]{babel}

% Usar codificación utf-8 para acentos y otros.
\usepackage[utf8]{inputenc}

%Dimensiones de los márgenes.
\usepackage[margin=1.5cm]{geometry}

% Insertar porciones de código
\usepackage{listings}

% Comenzar párrafos con separación no indentación.
\usepackage{parskip}
%enlaces
\usepackage{hyperref}
% Usar gráficos
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
%
% Usar contenedores flotantes para figuras.
\usepackage{float}

% Carpeta de las imágenes.
\graphicspath{{img/}}

% Configuración para porciones de código.
\lstset{
%	language=bash,
	basicstyle=\ttfamily\small,
%	numberstyle=\footnotesize,
%	numbers=left,
%	backgroundcolor=\color{gray!10},
%	frame=single,
	tabsize=4,
%	rulecolor=\color{black!30},
%	title=\lstname,
%	escapeinside={\%*}{*)},
	breaklines=true,
	breakatwhitespace=true,
%	framextopmargin=2pt,
%	framexbottommargin=2pt,
	extendedchars=false,
	inputencoding=utf8
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Propiedades
\title{Diseño de un lenguaje de Programación}

\author{Andrés Baamonde Lozano (andres.baamonde@udc.es)\\
	Rodrigo Arias Mallo (rodrigo.arias@udc.es)}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage 

\tableofcontents

\clearpage 



\section{Introducción}
En este documento se propone un lenguaje de programación orientado al cálculo 
numérico. La sintaxis es idéntica a C, con nuevas funcionalidades.

El objetivo consiste en explotar la capacidad de las máquinas modernas de 
realizar computaciones en paralelo. Tanto de las tarjetas gráficas (GPU) como de 
los procesadores multinúcleo (CPU). Y emplear esta capacidad para acelerar los 
procesos de cómputo que sean paralelizables y así hacer una ejecución más 
eficiente.

En concreto, se introducirán operaciones como el cálculo de productos 
matriciales, o operaciones vectoriales, realizadas en paralelo implícitamente.
\section{Paradigmas}
Programación imperativa procedural utilizando funciones y estructurado.
\section{Gestión de memoria}
Manual, se especifican tamaños o se inicializan las variables con un valor
determinado. El uso y la limpieza de la memoria corren a cargo del programador.Como en C la gestión de la memoria en tiempo de compilación se hará en la inicialización y la asignación dinámica(en tiempo de ejecución) se hará donde el programador considere oportuno.
\section{Sistema de tipos}
Tipado estático, deben especificarse todos los tipos de las variables. En las
matrices se deben especificar sus dimensiones y su tipo, que sólo puede ser uno
no se permiten matrices heterogéneas.La comprobación de la tipificación sera en tiempo de compilación por lo que la hará el compilador.Este sistema de tipos incrementa la fiabilidad de los programas procesados.
\section{Tipos de dato}
\subsection{Básicos}
\begin{itemize}
\item int
\item double
\item float
\item char
\item void
\item Punteros a tipos básicos (como en C).
\end{itemize}
\subsection{Complejos}
\begin{itemize}
\item vector
\item matrix
\item complex
\end{itemize}
\subsection{Modificadores de Tipos}
Existirán unos modificadores que permitirán compartir un determinado dato con la
GPU para así, en caso de que sea frecuentemente usado, evitar el tiempo de
enviarlo reiteradamente.
\section{Operadores}
\subsection{Tabla de operadores}
Para utilizar la GPU al máximo, lo más adecuado sería utilizar una tabla de
operadores como la de openCL. A mayores se incorporarán las funciones típicas de
imágenes, como convoluciones y filtros. En estos últimos se podrán aprovechar al
máximo las propiedades de las gráficas como el acceso a la memoria de los
núcleos vecinos.
\\
\begin{center}
\begin{tabular}{ l c r }
  add & + \\
  substract & - \\
  multiply & * \\
  divide &  / \\
  remainder &\% \\
  unary plus & + \\
  unary minus & - \\
  post and pre increment & ++\\
  post and pre decrement& --\\
  relational greater than & \textgreater \\
  relational less than & \textless \\
  relational greater-than or equal-to & \textgreater = \\
  relational less-than or equal-to & \textless= \\
  equal & == \\
  not equal  & != \\
  bitwise and & \& \\
  bitwise or &  | \\
  bitwise not & \textasciicircum \\
  bitwise not & \textasciitilde \\
  logical and & \&\& \\
  logical or & || \\
  logical exclusive or & \textasciicircum\textasciicircum \\
  logical unary not & ! \\
  ternary selection & ?: \\
  right shift & \textgreater\textgreater \\
  left shift & \textless\textless \\
  size of & sizeof \\
  comma &, \\
  dereference & * \\
  address-of & \& \\
  assignment & = \\	
\end{tabular}
\end{center}
\subsection{Sobrecarga operadores}
\subsubsection{Introducción}
Se añaden (sobrecargando los operadores) las operaciones con vectores y
matrices. El compilador podrá detectar posibles errores gracias al tipado
estático.
\subsubsection{Operadores vectoriales}
Suma, multiplicación y resta. Estos operadores funcionarían con los tipos vector
y matriz, pero también para su multiplicación por un escalar.
\section{Visibilidad}
\subsection{Visibilidad Local}
A nivel de función, la variable es accesible y puede manipulada sólo en la
función que es declarada. 
\subsection{Visibilidad Global}
A nivel de programa,la variable es accesible y puede ser  manipulada en todo el
programa.
\section{Tratamiento de errores}
\subsection{Matemáticos}
Se lanza una excepción que interrumpe el programa automáticamente (Lo hace el
compilador).
Errores :
\begin{itemize}
\item División entre 0.
\item Raíz de un número negativo(sin ser el destino un número imaginario).
\end{itemize}
\subsection{Overflow}
Se lanza una excepción que interrumpe el programa automáticamente (Lo hace el
compilador).\\
Estos errores se  producen cuando  un programa no controla adecuadamente la cantidad de datos que se copian sobre un área de memoria reservada a tal efecto.Si esa cantidad es superior a la anteriormente asignada los bytes se almacenan contiguamente pisando el contenido que pudiera existir previamente.
\subsection{Segmentación}
Se lanza una excepción que interrumpe el programa automáticamente (Lo hace el
compilador).
Errores :
\begin{itemize}
\item Desreferenciación punteros NULL.
\item Intento de acceder a memoria que el programa no tiene permisos.
\item Intentar acceder a una dirección de memoria inexistente.
\item Intentar escribir memoria de sólo lectura.
\item Un desbordamiento de búfer. 
\item Usando punteros no inicializados.
\end{itemize}
\section{Características}
\subsection{Inserción de código OpenCL}
Además de la programación normal del lenguaje, se permitirá añadir trozos de
código directamente en OpenCL, que nos permiten manejar la GPU manualmente y así
optimizar más nuestro código. 
 \\ También se incluyen operadores para la sincronización entre procesos y
 bloqueos para la posible concurrencia a una misma variable.Tarea que el
 planificador en las operaciones implementadas hará automáticamente.
\section{Programas o trozos de código}
\subsection{Suma de vectores}
Ejemplo sin paralelizar:
\begin{lstlisting}
#define N 100

float A[N], B[N], C[N];
int i;

for(i = 0; i < N; i++)
	C[i] = A[i] + B[i];
\end{lstlisting}

Ejemplo paralelizado:
\begin{lstlisting}
#define N 100

float A[N], B[N], C[N];

C = A + B;
\end{lstlisting}

Ejemplo de kernel para la suma de vectores en OpenCL:
\begin{lstlisting}
__kernel void vector_add(__global const int *A, __global const int *B, __global int *C)
{ 
    int i = get_global_id(0);
 
    C[i] = A[i] + B[i];
}
\end{lstlisting}
\subsection{Multiplicación de matrices}
Ejemplo sin paralelizar:
\begin{lstlisting}
#define N 100

float A[N][N], B[N][N], C[N][N];
float sum = 0.0;
int i, j, k;

for(i = 0; i < N; i++) {
	for(j = 0; j < N; j++) {
		sum = 0;
		for(k = 0; k < widthB; k++)
			sum += A[i][k] * B[k][j];
		C[i][j] = sum;
	}

}
\end{lstlisting}

Ejemplo paralelizado:
\begin{lstlisting}
#define N 100

float A[N][N], B[N][N], C[N][N];

C = A * B;
\end{lstlisting}

Ejemplo de kernel para la multiplicación en OpenCL:
\begin{lstlisting}
__kernel void matrix_mul(__global float* A, __global float* B, 
	__global float* C,  int widthA, int widthB )
{
    int i = get_global_id(0);
    int j = get_global_id(1);
    float value=0;
    for(int k = 0; k < widthA; k++)
    {
        value = value + A[k + j * widthA] * B[k*widthB + i];
    }
    C[i + widthA * j] = value;
}
\end{lstlisting}
\section{Pruebas de ejecución}
A continuación se muestran algunos resultados, para la multiplicación de matrices, al ejecutarse en secuencia, o en
paralelo:

\begin{lstlisting}
Tamano de matriz: 64x64
GPU envio:      4.070000E+02 us
GPU comp.:      1.159000E+03 us
GPU recep.:     3.410000E+02 us
GPU total:      2.148000E+03 us
GPU total:      2148.000000 us

CPU comp.:      3.190000E+02 us
CPU comp.:      319.000000 us

Aceleracion:    0.148510
Fallos comp.:   0
Max err.:       0.000000E+00
----------------------------------------
Tamano de matriz: 512x512
GPU envio:      2.384000E+03 us
GPU comp.:      3.621100E+04 us
GPU recep.:     1.562000E+03 us
GPU total:      4.046600E+04 us
GPU total:      40466.000000 us

CPU comp.:      3.352140E+05 us
CPU comp.:      335214.000000 us

Aceleracion:    8.283843
Fallos comp.:   0
Max err.:       0.000000E+00
-----------------------------------------
Tamano de matriz: 1024x1024
GPU envio:      5.669000E+03 us
GPU comp.:      3.109710E+05 us
GPU recep.:     5.350000E+03 us
GPU total:      3.222790E+05 us
GPU total:      322279.000000 us

CPU comp.:      1.205548E+07 us
CPU comp.:      12055485.000000 us

Aceleracion:    37.406983
Fallos comp.:   0
Max err.:       0.000000E+00
----------------------------------------
Tamano de matriz: 2048x2048
GPU envio:      2.168600E+04 us
GPU comp.:      2.418712E+06 us
GPU recep.:     1.743300E+04 us
GPU total:      2.458115E+06 us
GPU total:      2458115.000000 us = 2.46 s

CPU comp.:      1.115366E+08 us
CPU comp.:      111536649.000000 us = 111.5 s = 1 min 51 s

Aceleracion:    45.374870
Fallos comp.:   0
Max err.:       0.000000E+00
\end{lstlisting}

Cuanto más grande sea la matriz o el vector, más se aprecia la aceleración en
paralelo.
\section{Necesidades especiales}
\subsection{IDE}
\subsection{Debug}
Se puede compilar de forma secuencial en la CPU para así poder depurar sin
problemas en algoritmo en una primera versión y después poder optimizar el cálculo haciéndolo de forma paralela. Esto se propone debido a que el debug de un procesamiento paralelo es tedioso.
\subsection{Puntos de interrupción}
Al parar el proceso podemos inspeccionar el valor de las variables, los argumentos de la pila, y las direcciones de memoria sin que el proceso modifique estos valores hasta que no se lo indicas de esa forma al depurador.\\
También podemos inspeccionar el valor de los registros del procesador e incluso podemos cambiar cualquier dato tanto en los registros como en la memoria si queremos. Los breakpoints son sin duda la característica más comúnmente utilizada en un depurador. Por lo que serán incorporados a nuestro lenguaje.
\\ Existen dos tipos de breakpoints:
\begin{itemize}
\item software breakpoints(se usan específicamente para detener la CPU cuando se ejecuta una instrucción)
\item hardware breakpoints(a nivel de procesador no implementados por un lenguaje)
\end{itemize}
\subsection{Gráfica}
Necesidad de una targeta gráfica que soporte OpenCL para poder utilizar la
ejecución en paralelo.
\section{Arquitectura}
\subsection{Compilador}
Se dispondría de una especie de planificador, que detectaría el código paralelo,
lo dispondría en forma de grafo de ejecución.Una vez identificadas las partes
que pueden ir en paralelo, con esas partes se dividirían en bloques en función
al hardware disponible y posteriormente se enviarían al a GPU.\\
El codigo paraĺelo es especificado por el programador a través de los operadores
específicos(los operadores vectorialess).\\
En caso de hacer una operación entre tipos diferentes, el compilador
transformará el dato en el tipo necesario(si es posible) solo sí el dato de
donde se va a almacenar es el correcto.
\subsection{Errores}
A la hora de un error en la CPU es de fácil gestión, pero en la GPU nos
tendremos que asegurar de que la salída del programa es civilizada.
\section{Fuentes}
\begin{itemize}
\item \href{https://www.khronos.org/assets/uploads/developers/library/overview/opencl_overview.pdf}{ Funcionamiento OpenCL}
\item \href{https://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/operators.html}{Operadores OpenCL}
\item Transformar operaciones de Matrices para GPU:
\item \href{https://www.khronos.org/assets/uploads/developers/library/overview/opencl_overview.pdf#page=8}{Funcionamiento GPU}
\item \href{https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#page=51}{Modificadores de tipos}
\end{itemize}
\end{document}
